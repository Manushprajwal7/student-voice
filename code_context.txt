

// File: app/api/auth/[...nextauth]/route.js
"use client";
// app/api/auth/[...nextauth]/route.js

import NextAuth from "next-auth";
import { MongoDBAdapter } from "@auth/mongodb-adapter";
import clientPromise from "../../../lib/mongodb";
import { connectToDB } from "../../../../utils/db";
import User from "../../../../models/user";
import GoogleProvider from "next-auth/providers/google";
import {
  getAuth,
  initializeFirebaseAdmin,
} from "../../../../utils/firebase-admin";

initializeFirebaseAdmin(); // Ensure Firebase is initialized

export const authOptions = {
  adapter: MongoDBAdapter(clientPromise),
  providers: [
    GoogleProvider({
      clientId: process.env.GOOGLE_CLIENT_ID,
      clientSecret: process.env.GOOGLE_CLIENT_SECRET,
    }),
  ],
  secret: process.env.NEXTAUTH_SECRET,
  session: {
    strategy: "jwt",
  },
  callbacks: {
    async session({ session, token }) {
      try {
        await connectToDB();
        const sessionUser = await User.findOne({ email: session.user?.email });
        if (sessionUser) {
          if (session.user) {
            session.user.id = sessionUser._id.toString();
            session.user.token = token.sub;
          }
        }
        return session;
      } catch (error) {
        console.error("Error in session callback:", error);
        return Promise.resolve(session);
      }
    },
    async signIn({ user }) {
      try {
        await connectToDB();
        const userExists = await User.findOne({ email: user.email });
        if (!userExists) {
          await User.create({
            email: user.email,
            username: user.name.replace(/\s/g, "").toLowerCase(),
            image: user.image,
          });
        }
        return true;
      } catch (error) {
        console.error("Error in signIn callback:", error);
        return false;
      }
    },
  },
};

const handler = NextAuth(authOptions);

export { handler as GET, handler as POST };

// File: app/api/cors.js
import Cors from "cors";

const cors = Cors({
  methods: ["GET", "HEAD", "POST", "PUT", "DELETE", "PATCH", "OPTIONS"],
  origin: "*", // Be more specific in production
  optionsSuccessStatus: 200,
});

function runMiddleware(req, res, fn) {
  return new Promise((resolve, reject) => {
    fn(req, res, (result) => {
      if (result instanceof Error) {
        return reject(result);
      }
      return resolve(result);
    });
  });
}

export { cors, runMiddleware };

// File: app/api/issues/[id]/route.js
// app/api/issues/[id]/route.js
import { NextResponse } from "next/server";
import dbConnect from "../../../lib/dbConnect";
import Issue from "../../../../models/Issue";
import {
  initializeFirebaseAdmin,
  getAuth,
} from "../../../../utils/firebase-admin";

initializeFirebaseAdmin();

export async function GET(request, { params }) {
  const { id } = params;

  try {
    await dbConnect();
    const issue = await Issue.findById(id);

    if (!issue) {
      return NextResponse.json(
        { success: false, error: "Issue not found" },
        { status: 404 }
      );
    }

    return NextResponse.json({ success: true, data: issue });
  } catch (error) {
    console.error("Error fetching issue:", error);
    return NextResponse.json(
      { success: false, error: "Error fetching issue" },
      { status: 500 }
    );
  }
}

export async function PATCH(request, { params }) {
  const { id } = params;
  const authHeader = request.headers.get("authorization");

  if (!authHeader || !authHeader.startsWith("Bearer ")) {
    return NextResponse.json(
      { success: false, error: "Unauthorized" },
      { status: 401 }
    );
  }

  const token = authHeader.split("Bearer ")[1];

  try {
    const auth = getAuth();
    await auth.verifyIdToken(token);

    await dbConnect();
    const updates = await request.json();
    const updatedIssue = await Issue.findByIdAndUpdate(
      id,
      { status: updates.status, updatedAt: new Date() },
      { new: true }
    );

    if (!updatedIssue) {
      return NextResponse.json(
        { success: false, error: "Issue not found" },
        { status: 404 }
      );
    }

    return NextResponse.json({
      success: true,
      message: "Issue updated successfully",
      data: updatedIssue,
    });
  } catch (error) {
    console.error("Error updating issue:", error);
    return NextResponse.json(
      { success: false, error: "Error updating issue: " + error.message },
      { status: 500 }
    );
  }
}

export async function DELETE(request, { params }) {
  const { id } = params;
  const authHeader = request.headers.get("authorization");

  if (!authHeader || !authHeader.startsWith("Bearer ")) {
    return NextResponse.json(
      { success: false, error: "Unauthorized" },
      { status: 401 }
    );
  }

  const token = authHeader.split("Bearer ")[1];

  try {
    const auth = getAuth();
    await auth.verifyIdToken(token);

    await dbConnect();
    const deletedIssue = await Issue.findByIdAndDelete(id);

    if (!deletedIssue) {
      return NextResponse.json(
        { success: false, error: "Issue not found" },
        { status: 404 }
      );
    }

    return NextResponse.json({
      success: true,
      message: "Issue deleted successfully",
    });
  } catch (error) {
    console.error("Error deleting issue:", error);
    return NextResponse.json(
      { success: false, error: "Error deleting issue: " + error.message },
      { status: 500 }
    );
  }
}

// File: app/api/issues/new_issues/route.js
// app/api/issues/new_issues/route.js
import { connectToDB } from "../../../../utils/db";
import Issue from "../../../../models/Issue";
import {
  getAuth,
  initializeFirebaseAdmin,
} from "../../../../utils/firebase-admin";

initializeFirebaseAdmin();

export const POST = async (req) => {
  try {
    const { prompt, tag, category } = await req.json();
    if (!prompt || !tag || !category) {
      return new Response("Missing required fields: prompt, tag, or category", {
        status: 400,
      });
    }

    const authHeader = req.headers.get("authorization");
    if (!authHeader || !authHeader.startsWith("Bearer ")) {
      return new Response("Unauthorized", { status: 401 });
    }

    const token = authHeader.split("Bearer ")[1];
    const auth = getAuth();
    const decodedToken = await auth.verifyIdToken(token);

    await connectToDB();

    const newIssue = new Issue({
      creator: decodedToken.uid,
      creatorEmail: decodedToken.email,
      creatorName: decodedToken.name || "Anonymous",
      prompt,
      tag,
      category,
    });

    await newIssue.save();

    return new Response(JSON.stringify(newIssue), { status: 201 });
  } catch (error) {
    console.error("Error creating issue:", error);
    return new Response(`Failed to create a new issue: ${error.message}`, {
      status: 500,
    });
  }
};

// File: app/api/issues/route.js
import dbConnect from "../../lib/dbConnect";
import Issue from "../../../models/Issue";

export async function GET(request) {
  try {
    await dbConnect();
    const issues = await Issue.find({})
      .sort({ createdAt: -1 }) // Sort in descending order
      .populate("creator") // Populate creator field if needed
      .exec();

    return new Response(JSON.stringify(issues), { status: 200 });
  } catch (error) {
    console.error("Failed to fetch issues:", error);
    return new Response("Failed to fetch issues", { status: 500 });
  }
}

// File: app/api/students/[studentId]/posts/route.js
import { connectToDB } from "../../../../../utils/db";
import Post from "../../../../../models/post";

export async function GET(req, { params }) {
  const { studentId } = params;

  try {
    console.log("Fetching posts for student:", studentId);

    // Connect to the database
    await connectToDB();

    // Fetch posts for the given student ID
    const posts = await Post.find({ studentId: studentId });

    console.log("Posts fetched successfully");
    return new Response(JSON.stringify(posts), { status: 200 });
  } catch (error) {
    console.error("Error fetching posts:", error);
    return new Response(
      JSON.stringify({ error: "Error fetching posts", details: error.message }),
      { status: 500 }
    );
  }
}

export async function DELETE(req, { params }) {
  const { studentId } = params;
  const { postId } = await req.json(); // Assuming postId is sent in the request body

  try {
    console.log("Attempting to delete post for student:", studentId);

    // Connect to the database
    await connectToDB();

    // Delete the post for the given student ID and post ID
    await Post.findOneAndDelete({ _id: postId, studentId: studentId });

    console.log("Post deleted successfully");
    return new Response(
      JSON.stringify({ message: "Post deleted successfully" }),
      { status: 200 }
    );
  } catch (error) {
    console.error("Error deleting post:", error);
    return new Response(
      JSON.stringify({ error: "Error deleting post", details: error.message }),
      { status: 500 }
    );
  }
}

// File: app/context/AuthContext.js
// File: app/context/AuthContext.js
"use client";
import { createContext, useContext, useEffect, useState } from "react";
import {
  onAuthStateChanged,
  signOut,
  signInWithPopup,
  GoogleAuthProvider,
} from "firebase/auth";
import { auth, googleProvider } from "../firebase";

const AuthContext = createContext({});

export const useAuth = () => useContext(AuthContext);

export const AuthContextProvider = ({ children }) => {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(true);

  // List of admin emails - Replace with actual admin emails
  const adminEmails = [
    "admin@college.edu",
    "dean@college.edu",
    "manushprajwal1@gmail.com",
  ];

  useEffect(() => {
    const unsubscribe = onAuthStateChanged(auth, async (firebaseUser) => {
      if (firebaseUser) {
        const token = await firebaseUser.getIdToken();
        const isAdmin = adminEmails.includes(firebaseUser.email);
        const userData = {
          uid: firebaseUser.uid,
          email: firebaseUser.email,
          displayName: firebaseUser.displayName,
          photoURL: firebaseUser.photoURL,
          token: token,
          isAdmin: isAdmin,
        };
        setUser(userData);
        console.log("User data:", userData); // Debugging: Check user details
        localStorage.setItem("user", JSON.stringify(userData));
      } else {
        setUser(null);
        localStorage.removeItem("user");
      }
      setLoading(false);
    });

    return () => unsubscribe();
  }, []);

  const googleSignIn = async () => {
    try {
      const result = await signInWithPopup(auth, googleProvider);
      const user = result.user;
      console.log("Google Sign-In successful:", user);
    } catch (error) {
      console.error("Error signing in with Google:", error);
    }
  };

  const logOut = async () => {
    try {
      await signOut(auth);
    } catch (error) {
      console.error("Error signing out:", error);
    }
  };

  return (
    <AuthContext.Provider value={{ user, loading, googleSignIn, logOut }}>
      {!loading && children}
    </AuthContext.Provider>
  );
};

// File: app/firebase.js
import { initializeApp, getApps } from "firebase/app";
import { getAuth, GoogleAuthProvider } from "firebase/auth";

const firebaseConfig = {
  apiKey: "AIzaSyCmy23J0VpiceqEUPx3_dLRgCay14BLMfc",
  authDomain: "studentvoice-11226.firebaseapp.com",
  projectId: "studentvoice-11226",
  storageBucket: "studentvoice-11226.appspot.com",
  messagingSenderId: "210590252305",
  appId: "1:210590252305:web:c075d2b8913843c8d3e0b0",
  measurementId: "G-SDBEK9R478",
};

// Initialize Firebase
let app;
if (!getApps().length) {
  app = initializeApp(firebaseConfig);
} else {
  app = getApps()[0];
}

const auth = getAuth(app);
const googleProvider = new GoogleAuthProvider();

export { auth, googleProvider };

// File: app/globals.css
@tailwind base;
@tailwind components;
@tailwind utilities;

:root {
  --foreground-rgb: 0, 0, 0; /* Black text */
  --background-rgb: 255, 255, 255; /* White background */
}

body {
  color: rgb(var(--foreground-rgb)); /* Black text */
  background-color: #dfe0e4; /* White background */
}

@layer utilities {
  .text-balance {
    text-wrap: balance;
  }
}

// File: app/issues/[id]/IssueDetailPage.js
// File: app/issues/[id]/IssueDetailsPage.js
"use client";

import { useEffect, useState } from "react";
import { useParams } from "next/navigation";
import { useAuth } from "../../context/AuthContext";

export default function IssueDetailsPage() {
  const [issue, setIssue] = useState(null);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState(null);
  const params = useParams();
  const { id } = params;
  const { user } = useAuth();

  useEffect(() => {
    if (id) {
      fetchIssue();
    }
  }, [id]);

  const fetchIssue = async () => {
    try {
      const response = await fetch(`/api/issues/${id}`);
      if (!response.ok) {
        throw new Error("Failed to fetch issue");
      }
      const data = await response.json();
      setIssue(data.data);
    } catch (err) {
      setError("Error fetching issue");
      console.error("Error fetching issue:", err);
    } finally {
      setIsLoading(false);
    }
  };

  if (isLoading) return <div className="text-center mt-20">Loading...</div>;
  if (error)
    return <div className="text-center mt-20 text-red-500">Error: {error}</div>;
  if (!issue) return <div className="text-center mt-20">No issue found</div>;

  return (
    <div className="max-w-4xl mx-auto px-4 py-8 mt-20">
      <h1 className="text-3xl font-bold mb-4">{issue.prompt}</h1>
      <div className="bg-gray-100 p-4 rounded-lg mb-6">
        <p className="text-gray-700">
          <span className="font-semibold">Status:</span>{" "}
          <span
            className={`${
              issue.status === "resolved" ? "text-green-600" : "text-blue-600"
            }`}
          >
            {issue.status}
          </span>
        </p>
        <p className="text-gray-700">
          <span className="font-semibold">Category:</span> {issue.category}
        </p>
        <p className="text-gray-700">
          <span className="font-semibold">Created by:</span> {issue.creatorName}
        </p>
        <p className="text-gray-700">
          <span className="font-semibold">Email:</span> {issue.creatorEmail}
        </p>
      </div>
    </div>
  );
}

// File: app/issues/[id]/page.js
// File: app/issues/[id]/page.js
"use client";

import { useEffect, useState } from "react";
import { useParams, useRouter } from "next/navigation";
import { useAuth } from "../../context/AuthContext";
import Image from "next/image";

export default function IssuePage() {
  const [issue, setIssue] = useState(null);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState(null);
  const [isResolving, setIsResolving] = useState(false);
  const [showConfirmation, setShowConfirmation] = useState(false);
  const params = useParams();
  const router = useRouter();
  const { id } = params;
  const { user } = useAuth();

  useEffect(() => {
    if (id) {
      fetchIssue();
    }
  }, [id]);

  const fetchIssue = async () => {
    try {
      const response = await fetch(`/api/issues/${id}`, {
        headers: {
          Authorization: `Bearer ${user?.token}`, // Include token if available
        },
      });
      if (!response.ok) {
        throw new Error("Failed to fetch issue");
      }
      const data = await response.json();
      setIssue(data.data);
    } catch (err) {
      setError("Error fetching issue");
      console.error("Error fetching issue:", err);
    } finally {
      setIsLoading(false);
    }
  };

  const resolveIssue = async () => {
    if (!user?.token) {
      setError("You must be logged in to resolve issues");
      return;
    }

    setIsResolving(true);
    try {
      const response = await fetch(`/api/issues/${id}`, {
        method: "PATCH",
        headers: {
          "Content-Type": "application/json",
          Authorization: `Bearer ${user.token}`,
        },
        body: JSON.stringify({ status: "resolved" }),
      });

      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(errorData.error || "Failed to resolve issue");
      }

      setShowConfirmation(true);
      setTimeout(() => {
        router.push("/");
      }, 2000);
    } catch (error) {
      console.error("Error resolving issue:", error);
      setError(error.message);
    } finally {
      setIsResolving(false);
    }
  };

  if (isLoading) return <div className="text-center mt-20">Loading...</div>;
  if (error)
    return <div className="text-center mt-20 text-red-500">Error: {error}</div>;
  if (!issue) return <div className="text-center mt-20">No issue found</div>;

  return (
    <div className="max-w-4xl mx-auto px-4 py-8 mt-20">
      <div className="mb-8 bg-gray-100 p-4 rounded-lg">
        <h2 className="text-xl font-semibold mb-2">Created by:</h2>
        <div className="flex items-center space-x-3">
          <div className="w-10 h-10 bg-gray-200 rounded-full flex items-center justify-center overflow-hidden">
            {issue.creatorImage ? (
              <Image
                src={issue.creatorImage}
                alt={issue.creatorName || "Creator"}
                width={40}
                height={40}
                className="object-cover"
              />
            ) : (
              (issue.creatorName || "A").charAt(0).toUpperCase()
            )}
          </div>
          <div>
            <p className="text-lg">{issue.creatorName || "Anonymous"}</p>
            <p className="text-gray-600">{issue.creatorEmail || "No Email"}</p>
          </div>
        </div>
      </div>
      <h1 className="text-3xl font-bold mb-4">{issue.prompt}</h1>
      <p className="text-gray-600 mb-4">
        Status:
        <span
          className={`${
            issue.status === "resolved" ? "text-green-600" : "text-blue-600"
          } ml-2`}
        >
          {issue.status}
        </span>
      </p>
      <p className="text-gray-600 mb-4">
        Category: {issue.category || "Uncategorized"}
      </p>
      <p className="text-gray-600 mb-4">
        Created at: {new Date(issue.createdAt).toLocaleString()}
      </p>
      <div className="mt-4">
        <h2 className="text-xl font-semibold mb-2">Tags:</h2>
        <div className="flex flex-wrap gap-2">
          {issue.tag.split(",").map((tag, index) => (
            <span
              key={index}
              className="bg-blue-100 text-blue-800 px-2 py-1 rounded-full text-sm"
            >
              #{tag.trim()}
            </span>
          ))}
        </div>
      </div>

      {/* Resolve Button for Admins */}
      {user?.isAdmin && issue.status !== "resolved" && (
        <button
          onClick={resolveIssue}
          disabled={isResolving}
          className={`mt-8 px-6 py-2 bg-green-600 text-white rounded-lg 
            ${
              isResolving
                ? "opacity-50 cursor-not-allowed"
                : "hover:bg-green-700"
            }
            transition duration-200`}
        >
          {isResolving ? "Resolving..." : "Resolve this issue"}
        </button>
      )}

      {showConfirmation && (
        <div className="fixed top-0 left-0 w-full h-full flex items-center justify-center bg-black bg-opacity-50">
          <div className="bg-white p-6 rounded-lg shadow-xl">
            <p className="text-green-600 font-semibold text-lg">
              Issue resolved successfully!
            </p>
            <p className="text-gray-600 mt-2">Redirecting to homepage...</p>
          </div>
        </div>
      )}
    </div>
  );
}

// File: app/issues/page.js
// File: app/issues/page.js
"use client";
import { useState } from "react";
import { useRouter } from "next/navigation";
import { useAuth } from "../context/AuthContext";

const categories = [
  "All",
  "Teaching",
  "Women Rights",
  "Ragging",
  "Cultural Events",
  "Campus",
  "Sports",
  "Fest",
  "Infrastructure",
  "Academics",
  "Student Services",
  "Extracurricular Activities",
];

async function createIssue(token, prompt, tag, category) {
  try {
    const response = await fetch("/api/issues/new_issues", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Authorization: `Bearer ${token}`,
      },
      body: JSON.stringify({ prompt, tag, category }),
    });

    if (!response.ok) {
      const errorMessage = await response.text();
      throw new Error(`Error creating issue: ${errorMessage}`);
    }

    const result = await response.json();
    console.log("Issue created successfully:", result);
    return result;
  } catch (error) {
    console.error("Error creating issue:", error);
    throw error;
  }
}

export default function IssuesPage() {
  const [prompt, setPrompt] = useState("");
  const [tag, setTag] = useState("");
  const [category, setCategory] = useState("");
  const { user } = useAuth();
  const router = useRouter();

  const handleSubmit = async (e) => {
    e.preventDefault();
    if (!user) {
      alert("You must be signed in to create an issue.");
      return;
    }
    try {
      await createIssue(user.token, prompt, tag, category);
      setPrompt("");
      setTag("");
      setCategory("");
      alert("Issue created successfully!");
      router.push("/");
    } catch (error) {
      alert("Failed to create issue. Please try again.");
    }
  };

  const handleCancel = () => {
    setPrompt("");
    setTag("");
    setCategory("");
    router.push("/");
  };

  return (
    <section className="w-full max-w-4xl pt-20 mx-auto px-4 py-12">
      <h1 className="text-4xl font-bold text-center text-gray-800 mb-4">
        Create New Issue
      </h1>
      <p className="text-xl text-center text-gray-600 mb-12 max-w-2xl mx-auto">
        Share your concerns with the college community. Your voice matters!
      </p>

      <form onSubmit={handleSubmit} className="mb-8">
        <textarea
          value={prompt}
          onChange={(e) => setPrompt(e.target.value)}
          placeholder="Describe your concern"
          required
          className="w-full h-40 p-4 mb-4 rounded-lg border border-gray-300 focus:outline-none focus:ring-2 focus:ring-blue-500"
        />
        <input
          type="text"
          value={tag}
          onChange={(e) => setTag(e.target.value)}
          placeholder="Add tags (comma-separated)"
          required
          className="w-full px-4 py-2 mb-4 rounded-lg border border-gray-300 focus:outline-none focus:ring-2 focus:ring-blue-500"
        />
        <select
          value={category}
          onChange={(e) => setCategory(e.target.value)}
          required
          className="w-full px-4 py-2 mb-4 rounded-lg border border-gray-300 focus:outline-none focus:ring-2 focus:ring-blue-500"
        >
          <option value="">Select a category</option>
          {categories.map((cat) => (
            <option key={cat} value={cat}>
              {cat}
            </option>
          ))}
        </select>
        <div className="flex justify-between">
          <button
            type="button"
            onClick={handleCancel}
            className="px-4 py-2 bg-red-600 text-white rounded-lg hover:bg-red-700 focus:outline-none focus:ring-2 focus:ring-red-500 focus:ring-offset-2"
          >
            Cancel
          </button>
          <button
            type="submit"
            className="px-3 py-1 bg-blue-600 text-white rounded-lg hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 text-sm"
          >
            Create Issue
          </button>
        </div>
      </form>
    </section>
  );
}

// File: app/layout.js
// File: app/layout.js
import { Inter } from "next/font/google";
import "./globals.css";
import Navigation from "../components/Navigation";
import { AuthContextProvider } from "./context/AuthContext";

const inter = Inter({ subsets: ["latin"] });

export const metadata = {
  title: "Student Voice",
  description: "Come Together and Share Your Voice!",
};

export default function RootLayout({ children }) {
  return (
    <html lang="en">
      <body>
        <AuthContextProvider>
          <Navigation />
          {children}
        </AuthContextProvider>
      </body>
    </html>
  );
}

// File: app/lib/actions/issue.action.js
import connectToDatabase from "@app/lib/mongoose";
import Issue from "@models/Issue";

export async function fetchIssues() {
  try {
    await connectToDatabase();
    const issues = await Issue.find({})
      .sort({ createdAt: -1 })
      .populate("author", "name image")
      .lean();
    return JSON.parse(JSON.stringify(issues));
  } catch (error) {
    console.error("Error fetching issues:", error);
    return null;
  }
}

// You can add other issue-related actions here in the future

// File: app/lib/actions/user.action.js
import connectToDatabase from "@app/lib/mongoose";
import User from "@/models/user.model";
import Problem from "@/models/problem.model";

export async function getUserProfile(userId) {
  try {
    await connectToDatabase();
    const user = await User.findById(userId).lean();
    if (!user) {
      throw new Error("User not found");
    }
    const problems = await Problem.find({ author: userId }).lean();
    return {
      ...user,
      problems,
    };
  } catch (error) {
    console.error("Error fetching user profile:", error);
    throw error;
  }
}

export async function deleteUserProblem(userId, problemId) {
  try {
    await connectToDatabase();
    const problem = await Problem.findOneAndDelete({
      _id: problemId,
      author: userId,
    });
    if (!problem) {
      throw new Error("Problem not found or user not authorized");
    }
    return problem;
  } catch (error) {
    console.error("Error deleting user problem:", error);
    throw error;
  }
}

// File: app/lib/dbConnect.js
import mongoose from "mongoose";

const MONGODB_URI = process.env.MONGODB_URI;

if (!MONGODB_URI) {
  throw new Error(
    "Please define the MONGODB_URI environment variable inside .env.local"
  );
}

let cached = global.mongoose;

if (!cached) {
  cached = global.mongoose = { conn: null, promise: null };
}

async function dbConnect() {
  if (cached.conn) {
    return cached.conn;
  }

  if (!cached.promise) {
    const opts = {
      bufferCommands: false,
    };

    cached.promise = mongoose.connect(MONGODB_URI, opts).then((mongoose) => {
      return mongoose;
    });
  }

  try {
    cached.conn = await cached.promise;
  } catch (e) {
    cached.promise = null;
    throw e;
  }

  return cached.conn;
}

export default dbConnect;

// File: app/lib/mongodb.js
// lib/mongodb.js
import mongoose from "mongoose";

const MONGODB_URI = process.env.MONGODB_URI;
const DB_NAME = "studentVoice";

if (!MONGODB_URI) {
  throw new Error(
    "Please define the MONGODB_URI environment variable inside .env.local"
  );
}

let cached = global.mongoose;

if (!cached) {
  cached = global.mongoose = { conn: null, promise: null };
}

async function dbConnect() {
  if (cached.conn) {
    return cached.conn;
  }

  if (!cached.promise) {
    cached.promise = mongoose
      .connect(MONGODB_URI, {
        dbName: DB_NAME, // Ensure database name is consistent
      })
      .then((mongoose) => {
        return mongoose;
      });
  }
  cached.conn = await cached.promise;
  return cached.conn;
}

export default dbConnect;

// File: app/log-issues/index.js
"use client";
import Form from "@/components/Form";
import { useState } from "react";
import { useRouter } from "next/navigation";
import { UserAuth } from "@/app/context/AuthContext";

const CreateIssue = () => {
  const router = useRouter();
  const { user } = UserAuth();
  const [submitting, setSubmitting] = useState(false);
  const [post, setPost] = useState({ prompt: "", tag: "" });

  const createIssue = async (e) => {
    e.preventDefault();
    setSubmitting(true);

    if (!user) return alert("You must be signed in to create an issue.");

    try {
      const response = await fetch("/api/issues/new_issues", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          userId: user.uid,
          prompt: post.prompt,
          tag: post.tag,
        }),
      });

      if (response.ok) {
        router.push("/");
      } else {
        console.error("Failed to create issue:", await response.text());
      }
    } catch (error) {
      console.error("Failed to create issue:", error.message);
    } finally {
      setSubmitting(false);
    }
  };

  return (
    <Form
      type="Create"
      post={post}
      setPost={setPost}
      submitting={submitting}
      handleSubmit={createIssue}
    />
  );
};

export default CreateIssue;

// File: app/page.js
// app/page.js
"use client";
import React, { useEffect, useState } from "react";
import Feed from "../components/Feed";
import { useAuth } from "./context/AuthContext";
import { useSearchParams } from "next/navigation";

export default function Home() {
  const [issues, setIssues] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  const { user } = useAuth();
  const searchParams = useSearchParams();
  const category = searchParams.get("category");

  useEffect(() => {
    async function loadIssues() {
      if (!user) {
        setLoading(false);
        return;
      }
      try {
        setLoading(true);
        const response = await fetch("/api/issues", {
          headers: {
            Authorization: `Bearer ${user.token}`,
          },
        });
        if (response.ok) {
          const issuesData = await response.json();
          setIssues(issuesData);
        } else {
          throw new Error("Failed to fetch issues");
        }
      } catch (error) {
        console.error("Error loading issues:", error);
        setError("Failed to load issues. Please try again later.");
      } finally {
        setLoading(false);
      }
    }

    loadIssues();
  }, [user]);

  let filteredIssues;
  if (user && user.isAdmin) {
    // Show all issues for admins
    filteredIssues = issues;
  } else {
    // Filter issues by category for normal users
    filteredIssues =
      category && category !== "All"
        ? issues.filter((issue) => issue.category === category)
        : issues;
  }

  if (loading) {
    return (
      <main className="flex min-h-screen flex-col items-center justify-center p-4 pt-10 sm:p-24">
        <p>Loading...</p>
      </main>
    );
  }

  if (error) {
    return (
      <main className="flex min-h-screen flex-col items-center justify-center p-4 pt-10 sm:p-24">
        <div
          className="bg-red-100 border-l-4 border-red-500 text-red-700 p-4 mb-8"
          role="alert"
        >
          <p className="font-bold">Error</p>
          <p>{error}</p>
        </div>
      </main>
    );
  }

  return (
    <main className="flex flex-col items-center justify-center min-h-screen py-8 px-4 lg:py-16 lg:px-8">
      <section className="w-full max-w-4xl mx-auto p:4">
        <div className="bg-gray-100 rounded-lg shadow-lg p-6 md:p-10">
          <h1 className="text-3xl md:text-4xl font-bold text-gray-800 mb-4">
            <span className="text-black">Student Voice</span>
            <br className="hidden md:block" />
            <span className="text-black">College Community Concerns</span>
          </h1>
          <p className="text-lg md:text-xl text-gray-600 mb-8 max-w-2xl">
            Explore issues raised by students in our college community. Voice
            your support and make a difference.
          </p>

          {user ? (
            <Feed initialIssues={filteredIssues} />
          ) : (
            <div
              className="bg-yellow-100 border-l-4 border-yellow-500 text-yellow-700 p-4 mb-8"
              role="alert"
            >
              <p className="font-bold">Please log in</p>
              <p>You need to be logged in to view and interact with issues.</p>
            </div>
          )}
        </div>
      </section>
    </main>
  );
}

// File: app/profile/[id]/index.js
/**app/profile/[id]/index.js */
"use client";

import { useEffect, useState } from "react";
import { useSearchParams } from "next/navigation";
import Profile from "@components/Profile";

const UserProfile = ({ params }) => {
  const searchParams = useSearchParams();
  const userName = searchParams.get("name");
  const [userPosts, setUserPosts] = useState([]);

  useEffect(() => {
    const fetchPosts = async () => {
      try {
        const response = await fetch(`/api/students/${params.id}/posts`);
        if (response.ok) {
          const data = await response.json();
          setUserPosts(data);
        } else {
          console.error("Failed to fetch user posts:", await response.text());
        }
      } catch (error) {
        console.error("Failed to fetch user posts:", error.message);
      }
    };

    if (params.id) fetchPosts();
  }, [params.id]);

  return (
    <Profile
      name={userName}
      desc={`Welcome ${userName}, do share your experiences`}
      data={userPosts}
    />
  );
};

export default UserProfile;

// File: app/profile/page.js
// File: app/profile/page.js
"use client";
import { useEffect, useState } from "react";
import { useAuth } from "../context/AuthContext";
import ProblemCard from "../../components/ProblemCard";

const ProfilePage = () => {
  const { user } = useAuth();
  const [myIssues, setMyIssues] = useState([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState(null);

  useEffect(() => {
    const fetchIssues = async () => {
      if (!user) {
        setIsLoading(false);
        return;
      }
      try {
        const response = await fetch(`/api/issues`, {
          headers: {
            Authorization: `Bearer ${user.token}`,
          },
        });
        if (response.ok) {
          const data = await response.json();
          // Filter issues created by the current user
          const userIssues = data.filter((issue) => issue.creator === user.uid);
          setMyIssues(userIssues || []);
        } else {
          throw new Error(await response.text());
        }
      } catch (error) {
        console.error("Failed to fetch my issues:", error.message);
        setError("Failed to load issues. Please try again later.");
      } finally {
        setIsLoading(false);
      }
    };

    fetchIssues();
  }, [user]);

  const deleteIssue = async (issueId) => {
    if (!user) return;

    try {
      const response = await fetch(`/api/issues/${issueId}`, {
        method: "DELETE",
        headers: {
          Authorization: `Bearer ${user.token}`,
        },
      });

      if (response.ok) {
        setMyIssues((prevIssues) =>
          prevIssues.filter((issue) => issue._id !== issueId)
        );
      } else {
        console.error("Failed to delete issue:", await response.text());
        alert("Failed to delete the issue. Please try again.");
      }
    } catch (error) {
      console.error("Failed to delete issue:", error.message);
      alert("Failed to delete the issue. Please try again.");
    }
  };

  if (!user) {
    return (
      <div className="text-center mt-20">
        Please sign in to view your profile.
      </div>
    );
  }

  if (isLoading) {
    return <div className="text-center mt-20">Loading...</div>;
  }

  if (error) {
    return <div className="text-center mt-20 text-red-500">{error}</div>;
  }

  return (
    <div className="w-full max-w-4xl mx-auto px-4 py-8 mt-20">
      <h1 className="text-2xl font-bold mb-4">My Profile</h1>
      <h2 className="text-xl font-semibold mb-2">My Issues</h2>
      {myIssues.length === 0 ? (
        <p>No issues found.</p>
      ) : (
        <div className="grid gap-4 md:grid-cols-2 lg:grid-cols-3">
          {myIssues.map((issue) => (
            <div key={issue._id} className="relative">
              <ProblemCard problem={issue} handleTagClick={() => {}} />
              <button
                className="mt-2 px-4 py-2 bg-red-500 text-white rounded absolute bottom-2 right-2"
                onClick={() => deleteIssue(issue._id)}
              >
                Delete
              </button>
            </div>
          ))}
        </div>
      )}
    </div>
  );
};

export default ProfilePage;

// File: app/update_log/page.js
"use client";

import { useEffect, useState } from "react";
import { useRouter, useSearchParams } from "next/navigation";
import Form from "../../components/Form";
const UpdatePrompt = () => {
  const router = useRouter();
  const searchParams = useSearchParams();
  const promptId = searchParams.get("id");

  const [post, setPost] = useState({ prompt: "", tag: "" });
  const [submitting, setIsSubmitting] = useState(false);

  useEffect(() => {
    const getPromptDetails = async () => {
      try {
        const response = await fetch(`/api/issues/${promptId}`);
        if (response.ok) {
          const data = await response.json();
          setPost({ prompt: data.prompt, tag: data.tag });
        } else {
          console.error(
            "Failed to fetch prompt details:",
            await response.text()
          );
        }
      } catch (error) {
        console.error("Failed to fetch prompt details:", error.message);
      }
    };

    if (promptId) getPromptDetails();
  }, [promptId]);

  const updatePrompt = async (e) => {
    e.preventDefault();
    setIsSubmitting(true);

    if (!promptId) return alert("Missing LogId!");

    try {
      const response = await fetch(`/api/issues/${promptId}`, {
        method: "PATCH",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          prompt: post.prompt,
          tag: post.tag,
        }),
      });

      if (response.ok) {
        router.push("/");
      } else {
        console.error("Failed to update prompt:", await response.text());
      }
    } catch (error) {
      console.error("Failed to update prompt:", error.message);
    } finally {
      setIsSubmitting(false);
    }
  };

  return (
    <Form
      type="Edit"
      post={post}
      setPost={setPost}
      submitting={submitting}
      handleSubmit={updatePrompt}
    />
  );
};

export default UpdatePrompt;

// File: utils/db.js
// utils/db.js
import mongoose from "mongoose";

let isConnected = false;

export const connectToDB = async () => {
  if (isConnected) {
    console.log("MongoDB is already connected");
    return;
  }

  try {
    await mongoose.connect(process.env.MONGODB_URI, {
      dbName: "studentvoice",
    });

    isConnected = true;
    console.log("MongoDB connected");
  } catch (error) {
    console.error("Error connecting to MongoDB:", error);
  }
};

// File: utils/firebase-admin.js
// utils/firebase-admin.js
import { initializeApp, getApps, cert } from "firebase-admin/app";
import { getAuth } from "firebase-admin/auth";

const firebaseAdminConfig = {
  type: process.env.FIREBASE_TYPE,
  project_id: process.env.FIREBASE_PROJECT_ID,
  private_key_id: process.env.FIREBASE_PRIVATE_KEY_ID,
  private_key: process.env.FIREBASE_PRIVATE_KEY.replace(/\\n/g, "\n"),
  client_email: process.env.FIREBASE_CLIENT_EMAIL,
  client_id: process.env.FIREBASE_CLIENT_ID,
  auth_uri: process.env.FIREBASE_AUTH_URI,
  token_uri: process.env.FIREBASE_TOKEN_URI,
  auth_provider_x509_cert_url: process.env.FIREBASE_AUTH_PROVIDER_X509_CERT_URL,
  client_x509_cert_url: process.env.FIREBASE_CLIENT_X509_CERT_URL,
};

let firebaseApp;

export function initializeFirebaseAdmin() {
  if (!getApps().length) {
    try {
      firebaseApp = initializeApp({
        credential: cert(firebaseAdminConfig),
      });
      console.log("Firebase Admin initialized successfully");
    } catch (error) {
      console.error("Error initializing Firebase Admin:", error);
      throw error;
    }
  } else {
    firebaseApp = getApps()[0];
  }
  return firebaseApp;
}

export { getAuth };

