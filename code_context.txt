// File: components/CategoryDropdown.js
// File: components/CategoryDropdown.js
import { useState } from "react";
import { useRouter } from "next/navigation";

const categories = [
  "All",
  "Teaching",
  "Women Rights",
  "Ragging",
  "Cultural Events",
  "Campus",
  "Sports",
  "Fest",
  "Infrastructure",
  "Academics",
  "Student Services",
  "Extracurricular Activities",
];

const CategoryDropdown = () => {
  const [isOpen, setIsOpen] = useState(false);
  const router = useRouter();

  const handleCategorySelect = (category) => {
    setIsOpen(false);
    if (category === "All") {
      router.push("/");
    } else {
      router.push(`/?category=${encodeURIComponent(category)}`);
    }
  };

  return (
    <div className="relative">
      <button
        onClick={() => setIsOpen(!isOpen)}
        className="px-4 py-2 bg-gray-200 rounded-md focus:outline-none"
      >
        Categories
      </button>
      {isOpen && (
        <div className="absolute right-0 mt-2 w-56 bg-white rounded-md shadow-lg py-1 z-10">
          {categories.map((category) => (
            <button
              key={category}
              onClick={() => handleCategorySelect(category)}
              className="block w-full text-left px-4 py-2 text-sm text-gray-700 hover:bg-gray-100"
            >
              {category}
            </button>
          ))}
        </div>
      )}
    </div>
  );
};

export default CategoryDropdown;

// File: components/Feed.js
// File: components/Feed.js
"use client";

import React, { useState, useEffect } from "react";
import ProblemCard from "./ProblemCard";
import { useAuth } from "../app/context/AuthContext";
import { useSearchParams } from "next/navigation";

const Feed = () => {
  const [posts, setPosts] = useState([]);
  const [filteredPosts, setFilteredPosts] = useState([]);
  const [searchQuery, setSearchQuery] = useState(""); // State for search input
  const { user, loading } = useAuth();
  const searchParams = useSearchParams();
  const category = searchParams.get("category");

  useEffect(() => {
    async function fetchAllIssues() {
      try {
        const response = await fetch("/api/issues", {
          headers: {
            "Content-Type": "application/json",
          },
        });

        if (response.ok) {
          const issues = await response.json();
          setPosts(issues);
        } else {
          throw new Error("Failed to fetch issues");
        }
      } catch (error) {
        console.error("Error fetching issues:", error);
      }
    }

    fetchAllIssues();
  }, []);

  useEffect(() => {
    filterPosts();
  }, [category, posts, searchQuery]); // Re-run filter on category, posts, or search query change

  const filterPosts = () => {
    let filtered = posts;

    // Filter by category if selected
    if (category && category !== "All") {
      filtered = filtered.filter((post) => post.category === category);
    }

    // Filter by search query (username or tag)
    if (searchQuery) {
      const regex = new RegExp(searchQuery, "i");
      filtered = filtered.filter(
        (post) =>
          regex.test(post.creator?.username) || // Search by username
          regex.test(post.tag) // Search by tags
      );
    }

    setFilteredPosts(filtered);
  };

  const handleSearchChange = (e) => {
    setSearchQuery(e.target.value); // Update search query state
  };

  if (loading) return <div>Loading...</div>;

  return (
    <section className="w-full max-w-4xl mx-auto px-4 py-8">
      <h1 className="text-xl sm:text-2xl font-bold mb-6">Recent Issues</h1>

      {/* Search Bar */}
      <form className="mb-8">
        <input
          type="text"
          placeholder="Search by username or tags"
          value={searchQuery}
          onChange={handleSearchChange}
          className="w-full px-3 py-2 sm:px-4 sm:py-2 rounded-lg border border-gray-300 focus:outline-none focus:ring-2 focus:ring-blue-500"
        />
      </form>

      <div className="mt-8 grid gap-6 md:grid-cols-2 lg:grid-cols-3">
        {filteredPosts.map((issue) => (
          <ProblemCard key={issue._id} problem={issue} currentUser={user} />
        ))}
      </div>
    </section>
  );
};

export default Feed;

// File: components/Form.js
"use client";
import Link from "next/link";
import PropTypes from "prop-types";

const Form = ({ type, post, setPost, submitting, handleSubmit }) => {
  async function createIssue(userId, prompt, tag) {
    // Validate userId format
    if (
      typeof userId !== "string" ||
      userId.length !== 24 ||
      !/^[a-fA-F0-9]{24}$/.test(userId)
    ) {
      console.error("Invalid userId format:", userId);
      return;
    }

    try {
      const response = await fetch("/api/issues/new_issues", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({ userId, prompt, tag }),
      });

      if (!response.ok) {
        const errorMessage = await response.text();
        throw new Error(`Error creating issue: ${errorMessage}`);
      }

      const result = await response.json();
      console.log("Issue created successfully:", result);
    } catch (error) {
      console.error("Error creating issue:", error);
    }
  }

  return (
    <section className="w-full max-w-2xl mx-auto px-4 py-8">
      <h1 className="text-3xl font-bold text-gray-800 mb-2 text-left">
        {type} Issue
      </h1>
      <p className="text-gray-600 mb-8 text-left">
        {type} and share your concerns with the college, and let your concern
        reach everyone on this platform.
      </p>

      <form onSubmit={handleSubmit} className="space-y-6">
        <div>
          <label
            htmlFor="concern"
            className="block text-sm font-medium text-gray-700 mb-1"
          >
            Your Concern
          </label>
          <textarea
            id="concern"
            value={post?.prompt || ""}
            onChange={(e) => setPost({ ...post, prompt: e.target.value })}
            placeholder="Describe your concern here"
            required
            className="w-full h-40 px-3 py-2 text-gray-700 border rounded-lg focus:outline-none focus:border-blue-500"
          />
        </div>

        <div>
          <label
            htmlFor="tags"
            className="block text-sm font-medium text-gray-700 mb-1"
          >
            Tags{" "}
            <span className="text-gray-500">
              (e.g., #TOCE, #Culturals, #Sports)
            </span>
          </label>
          <input
            id="tags"
            value={post?.tag || ""}
            onChange={(e) => setPost({ ...post, tag: e.target.value })}
            type="text"
            placeholder="#Tag"
            required
            className="w-full px-3 py-2 text-gray-700 border rounded-lg focus:outline-none focus:border-blue-500"
          />
        </div>

        <div className="flex justify-end space-x-4">
          <Link
            href="/"
            className="px-4 py-2 bg-red-600 text-white rounded-lg hover:bg-red-400 focus:outline-none focus:ring-2 focus:ring-red-500 focus:ring-offset-2 disabled:opacity-50 text-sm"
          >
            Cancel
          </Link>

          <button
            type="submit"
            disabled={submitting}
            className="px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 disabled:opacity-50 text-sm"
          >
            {submitting ? `${type}ing...` : type}
          </button>
        </div>
      </form>
    </section>
  );
};

Form.propTypes = {
  type: PropTypes.string.isRequired,
  post: PropTypes.shape({
    prompt: PropTypes.string,
    tag: PropTypes.string,
  }),
  setPost: PropTypes.func.isRequired,
  submitting: PropTypes.bool.isRequired,
  handleSubmit: PropTypes.func.isRequired,
};

export default Form;

// File: components/Navigation.js
"use client";
import Link from "next/link";
import Image from "next/image";
import { useState } from "react";
import { useAuth } from "../app/context/AuthContext";
import CategoryDropdown from "./CategoryDropdown";

const Navigation = () => {
  const [toggleDropdown, setToggleDropdown] = useState(false);
  const { user, googleSignIn, logOut } = useAuth();

  const handleSignIn = async () => {
    try {
      await googleSignIn();
    } catch (error) {
      console.log("Error during sign in:", error);
    }
  };

  const handleSignOut = async () => {
    try {
      await logOut();
    } catch (error) {
      console.log("Error during sign out:", error);
    }
  };

  return (
    <nav className="fixed top-0 left-0 w-full bg-white shadow-md z-50 px-4 py-3 flex justify-between items-center">
      <Link href="/" className="flex items-center space-x-2">
        <Image
          src="/assets/logo.svg"
          alt="Student Voice logo"
          width={39}
          height={39}
          className="w-8 h-8 sm:w-10 sm:h-10"
        />
        {/* Updated text visibility and size for different screen sizes */}
        <p className="block font-sans font-semibold text-sm text-gray-800 sm:text-lg">
          Student Voice
        </p>
      </Link>

      <div className="flex items-center space-x-2 sm:space-x-4">
        <CategoryDropdown /> {/* Add this line */}
        {user ? (
          <>
            <Link
              href="/issues"
              className="rounded-full bg-blue-600 px-3 py-1 sm:px-4 sm:py-2 text-white text-xs sm:text-sm font-medium transition-colors hover:bg-blue-700"
            >
              Log an Issue
            </Link>

            <div className="relative">
              <Image
                src={user.photoURL || "/assets/default-profile.svg"}
                width={32}
                height={32}
                className="rounded-full cursor-pointer sm:w-10 sm:h-10"
                alt="User Profile"
                onClick={() => setToggleDropdown((prev) => !prev)}
              />
              {toggleDropdown && (
                <div className="absolute right-0 mt-2 w-48 bg-white rounded-md shadow-lg py-1">
                  <Link
                    href="/profile"
                    className="block px-4 py-2 text-sm text-gray-700 hover:bg-gray-100"
                    onClick={() => setToggleDropdown(false)}
                  >
                    My Profile
                  </Link>
                  <button
                    onClick={() => {
                      setToggleDropdown(false);
                      handleSignOut();
                    }}
                    className="block w-full text-left px-4 py-2 text-sm text-gray-700 hover:bg-gray-100"
                  >
                    Sign Out
                  </button>
                </div>
              )}
            </div>
          </>
        ) : (
          <button
            type="button"
            onClick={handleSignIn}
            className="rounded-full bg-blue-600 px-3 py-1 sm:px-4 sm:py-2 text-white text-xs sm:text-sm font-medium transition-colors hover:bg-blue-700"
          >
            Sign in With Google
          </button>
        )}
      </div>
    </nav>
  );
};

export default Navigation;

// File: components/ProblemCard.js
import React from "react";
import Link from "next/link";
import Image from "next/image";

const ProblemCard = ({ problem, handleTagClick }) => {
  const truncateText = (text, limit) => {
    const words = text.split(" ");
    return words.length > limit
      ? words.slice(0, limit).join(" ") + "..."
      : text;
  };

  if (!problem || !problem._id) {
    return (
      <div className="text-red-500 font-semibold">
        Error: Problem data is missing
      </div>
    );
  }

  const creatorName = problem.creatorName || "Anonymous";
  const creatorEmail = problem.creatorEmail || "No email";

  return (
    <Link href={`/issues/${problem._id}`} className="block">
      <div className="bg-white rounded-xl shadow-md hover:shadow-xl transition-shadow duration-300 overflow-hidden">
        <div className="p-6">
          <div className="flex items-center justify-between mb-3">
            <div className="flex items-center space-x-1">
              <div className="w-12 h-12 bg-gradient-to-br from-blue-400 to-purple-500 rounded-full flex items-center justify-center text-white font-bold text-lg overflow-hidden">
                {problem.creatorImage ? (
                  <Image
                    src={problem.creatorImage}
                    alt={creatorName}
                    width={48}
                    height={48}
                    className="object-cover"
                  />
                ) : (
                  creatorName.charAt(0).toUpperCase()
                )}
              </div>
              <div>
                <h3 className="text-lg font-semibold text-gray-800 truncate">
                  {creatorName}
                </h3>
                <p className="text-sm text-gray-500 truncate">{creatorEmail}</p>
              </div>
            </div>
            {problem.createdAt && (
              <span className="text-xs text-gray-400 whitespace-nowrap">
                {new Date(problem.createdAt).toLocaleDateString(undefined, {
                  month: "short",
                  day: "numeric",
                  year: "numeric",
                })}
              </span>
            )}
          </div>

          <p className="text-gray-600 mb-4 line-clamp-3">
            {truncateText(problem.prompt, 30)}
          </p>

          {problem.tag && (
            <div className="flex flex-wrap gap-2 mt-4">
              {problem.tag.split(",").map((tag, index) => (
                <button
                  key={index}
                  className="px-3 py-1 bg-blue-100 text-blue-600 rounded-full text-xs font-medium hover:bg-blue-200 transition-colors duration-200"
                  onClick={(e) => {
                    e.preventDefault();
                    handleTagClick && handleTagClick(tag.trim());
                  }}
                >
                  #{tag.trim()}
                </button>
              ))}
            </div>
          )}
        </div>
      </div>
    </Link>
  );
};

export default ProblemCard;

// File: components/Profile.js
// components/UserProfile.js
import { useAuth } from "../context/AuthContext";

const UserProfile = () => {
  const { user } = useAuth();

  if (!user) {
    return <div>Please sign in to view your profile.</div>;
  }

  return (
    <div>
      <h2>User Profile</h2>
      <p>Name: {user.displayName || "N/A"}</p>
      <p>Email: {user.email}</p>
    </div>
  );
};

export default UserProfile;

// File: components/Provider.js
"use client";
import { SessionProvider } from "next-auth/react";
const Provider = ({ children, session }) => {
  return <SessionProvider session={session}>{children}</SessionProvider>;
};

export default Provider;

// File: app/api/auth/[...nextauth]/route.js
"use client";

import NextAuth from "next-auth";
import { MongoDBAdapter } from "@auth/mongodb-adapter";
import clientPromise from "../../../lib/mongodb";
import { connectToDB } from "../../../../utils/db";
import User from "../../../../models/user";
import GoogleProvider from "next-auth/providers/google";

export const authOptions = {
  adapter: MongoDBAdapter(clientPromise),
  providers: [
    GoogleProvider({
      clientId: process.env.GOOGLE_CLIENT_ID,
      clientSecret: process.env.GOOGLE_CLIENT_SECRET,
    }),
  ],
  secret: process.env.NEXTAUTH_SECRET,
  session: {
    strategy: "jwt",
  },
  callbacks: {
    async session({ session, token }) {
      try {
        await connectToDB();
        const sessionUser = await User.findOne({ email: session.user?.email });
        if (sessionUser) {
          if (session.user) {
            session.user.id = sessionUser._id.toString();
            session.user.token = token.sub;
          }
        }
        return session;
      } catch (error) {
        console.error("Error in session callback:", error);
        return Promise.resolve(session);
      }
    },
    async signIn({ user }) {
      try {
        await connectToDB();
        const userExists = await User.findOne({ email: user.email });
        if (!userExists) {
          await User.create({
            email: user.email,
            username: user.name.replace(/\s/g, "").toLowerCase(),
            image: user.image,
          });
        }
        return true;
      } catch (error) {
        console.error("Error in signIn callback:", error);
        return false;
      }
    },
  },
};

const handler = NextAuth(authOptions);

export { handler as GET, handler as POST };

// File: app/api/cors.js
import Cors from "cors";

const cors = Cors({
  methods: ["GET", "HEAD", "POST", "PUT", "DELETE", "PATCH", "OPTIONS"],
  origin: "*", // Be more specific in production
  optionsSuccessStatus: 200,
});

function runMiddleware(req, res, fn) {
  return new Promise((resolve, reject) => {
    fn(req, res, (result) => {
      if (result instanceof Error) {
        return reject(result);
      }
      return resolve(result);
    });
  });
}

export { cors, runMiddleware };

// File: app/api/issues/[id]/route.js
import { NextResponse } from "next/server";
import dbConnect from "../../../lib/dbConnect";
import Issue from "../../../../models/Issue";

export async function GET(request, { params }) {
  const { id } = params;

  try {
    await dbConnect();
    const issue = await Issue.findById(id).populate("creator");

    if (!issue) {
      console.error(`Issue with ID ${id} not found.`);
      return NextResponse.json(
        { success: false, error: "Issue not found" },
        { status: 404 }
      );
    }

    return NextResponse.json({ success: true, data: issue });
  } catch (error) {
    console.error("Error fetching issue:", error);
    return NextResponse.json(
      { success: false, error: "Error fetching issue" },
      { status: 500 }
    );
  }
}

export async function PATCH(request, { params }) {
  const { id } = params;
  const { prompt, tag } = await request.json();

  try {
    await dbConnect();

    const existingIssue = await Issue.findById(id);
    if (!existingIssue) {
      console.error(`Issue with ID ${id} not found for update.`);
      return NextResponse.json(
        { success: false, error: "Issue not found" },
        { status: 404 }
      );
    }

    existingIssue.prompt = prompt;
    existingIssue.tag = tag;
    await existingIssue.save();

    console.log(`Issue with ID ${id} updated successfully.`);
    return NextResponse.json({
      success: true,
      message: "Issue updated successfully",
    });
  } catch (error) {
    console.error("Error updating issue:", error);
    return NextResponse.json(
      { success: false, error: "Error updating issue" },
      { status: 500 }
    );
  }
}

export async function DELETE(request, { params }) {
  const { id } = params;

  try {
    await dbConnect();

    const deletedIssue = await Issue.findByIdAndDelete(id);

    if (!deletedIssue) {
      console.error(`Issue with ID ${id} not found for deletion.`);
      return NextResponse.json(
        { success: false, error: "Issue not found" },
        { status: 404 }
      );
    }

    console.log(`Issue with ID ${id} deleted successfully.`);
    return NextResponse.json({
      success: true,
      message: "Issue deleted successfully",
    });
  } catch (error) {
    console.error("Error deleting issue:", error);
    return NextResponse.json(
      { success: false, error: "Error deleting issue" },
      { status: 500 }
    );
  }
}

// File: app/api/issues/new_issues/route.js
import { connectToDB } from "../../../../utils/db";
import Issue from "../../../../models/Issue";
import { getAuth } from "../../../../utils/firebase-admin";
import { initializeFirebaseAdmin } from "../../../../utils/firebase-admin";

initializeFirebaseAdmin(); // Ensure Firebase is initialized

export const POST = async (req) => {
  let prompt, tag, category;
  try {
    ({ prompt, tag, category } = await req.json());
  } catch (error) {
    return new Response("Invalid request body", { status: 400 });
  }

  if (!prompt || !tag || !category) {
    return new Response("Invalid input: Missing prompt, tag, or category", {
      status: 400,
    });
  }

  const authHeader = req.headers.get("authorization");
  if (!authHeader || !authHeader.startsWith("Bearer ")) {
    return new Response("Unauthorized", { status: 401 });
  }

  const token = authHeader.split("Bearer ")[1];

  try {
    const auth = getAuth();
    const decodedToken = await auth.verifyIdToken(token);
    const userId = decodedToken.uid;
    const userEmail = decodedToken.email;

    await connectToDB();

    const newIssue = new Issue({
      creator: userId,
      creatorEmail: userEmail,
      prompt,
      tag,
      category,
    });

    await newIssue.save();

    return new Response(JSON.stringify(newIssue), { status: 201 });
  } catch (error) {
    return new Response(`Failed to create a new issue: ${error.message}`, {
      status: 500,
    });
  }
};

// File: app/api/issues/route.js
import dbConnect from "../../lib/dbConnect";
import Issue from "../../../models/Issue";

export async function GET(request) {
  try {
    await dbConnect();
    const issues = await Issue.find({})
      .sort({ createdAt: -1 }) // Sort in descending order
      .populate("creator") // Populate creator field if needed
      .exec();

    return new Response(JSON.stringify(issues), { status: 200 });
  } catch (error) {
    console.error("Failed to fetch issues:", error);
    return new Response("Failed to fetch issues", { status: 500 });
  }
}

// File: app/api/students/[studentId]/posts/route.js
import { connectToDB } from "../../../../../utils/db";
import Post from "../../../../../models/post";

export async function GET(req, { params }) {
  const { studentId } = params;

  try {
    console.log("Fetching posts for student:", studentId);

    // Connect to the database
    await connectToDB();

    // Fetch posts for the given student ID
    const posts = await Post.find({ studentId: studentId });

    console.log("Posts fetched successfully");
    return new Response(JSON.stringify(posts), { status: 200 });
  } catch (error) {
    console.error("Error fetching posts:", error);
    return new Response(
      JSON.stringify({ error: "Error fetching posts", details: error.message }),
      { status: 500 }
    );
  }
}

export async function DELETE(req, { params }) {
  const { studentId } = params;
  const { postId } = await req.json(); // Assuming postId is sent in the request body

  try {
    console.log("Attempting to delete post for student:", studentId);

    // Connect to the database
    await connectToDB();

    // Delete the post for the given student ID and post ID
    await Post.findOneAndDelete({ _id: postId, studentId: studentId });

    console.log("Post deleted successfully");
    return new Response(
      JSON.stringify({ message: "Post deleted successfully" }),
      { status: 200 }
    );
  } catch (error) {
    console.error("Error deleting post:", error);
    return new Response(
      JSON.stringify({ error: "Error deleting post", details: error.message }),
      { status: 500 }
    );
  }
}

// File: app/context/AuthContext.js
"use client";
import { createContext, useContext, useEffect, useState } from "react";
import {
  onAuthStateChanged,
  signOut,
  signInWithPopup,
  GoogleAuthProvider,
} from "firebase/auth";
import { auth, googleProvider } from "../firebase";

const AuthContext = createContext({});

export const useAuth = () => useContext(AuthContext);

export const AuthContextProvider = ({ children }) => {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    const unsubscribe = onAuthStateChanged(auth, async (firebaseUser) => {
      if (firebaseUser) {
        const token = await firebaseUser.getIdToken();
        const userData = {
          uid: firebaseUser.uid,
          email: firebaseUser.email,
          displayName: firebaseUser.displayName,
          photoURL: firebaseUser.photoURL,
          token: token,
        };
        setUser(userData);
        localStorage.setItem("user", JSON.stringify(userData));
      } else {
        setUser(null);
        localStorage.removeItem("user");
      }
      setLoading(false);
    });

    return () => unsubscribe();
  }, []);

  const googleSignIn = async () => {
    try {
      const result = await signInWithPopup(auth, googleProvider);
      const user = result.user;
      console.log("Google Sign-In successful:", user);
    } catch (error) {
      console.error("Error signing in with Google:", error);
    }
  };

  const logOut = async () => {
    try {
      await signOut(auth);
    } catch (error) {
      console.error("Error signing out:", error);
    }
  };

  return (
    <AuthContext.Provider value={{ user, loading, googleSignIn, logOut }}>
      {!loading && children}
    </AuthContext.Provider>
  );
};

// File: app/firebase.js
import { initializeApp, getApps } from "firebase/app";
import { getAuth, GoogleAuthProvider } from "firebase/auth";

const firebaseConfig = {
  apiKey: "AIzaSyCmy23J0VpiceqEUPx3_dLRgCay14BLMfc",
  authDomain: "studentvoice-11226.firebaseapp.com",
  projectId: "studentvoice-11226",
  storageBucket: "studentvoice-11226.appspot.com",
  messagingSenderId: "210590252305",
  appId: "1:210590252305:web:c075d2b8913843c8d3e0b0",
  measurementId: "G-SDBEK9R478",
};

// Initialize Firebase
let app;
if (!getApps().length) {
  app = initializeApp(firebaseConfig);
} else {
  app = getApps()[0];
}

const auth = getAuth(app);
const googleProvider = new GoogleAuthProvider();

export { auth, googleProvider };

// File: app/globals.css
@tailwind base;
@tailwind components;
@tailwind utilities;

:root {
  --foreground-rgb: 0, 0, 0; /* Black text */
  --background-rgb: 255, 255, 255; /* White background */
}

body {
  color: rgb(var(--foreground-rgb)); /* Black text */
  background-color: #dfe0e4; /* White background */
}

@layer utilities {
  .text-balance {
    text-wrap: balance;
  }
}

// File: app/issues/[id]/IssueDetailPage.js
// File: app/issues/[id]/page.js
"use client";

import { useEffect, useState } from "react";
import { useParams } from "next/navigation";

export default function IssuePage() {
  const [issue, setIssue] = useState(null);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState(null);
  const params = useParams();
  const { id } = params;

  useEffect(() => {
    if (id) {
      fetchIssue();
    }
  }, [id]);

  const fetchIssue = async () => {
    try {
      const response = await fetch(`/api/issues/${id}`);
      if (!response.ok) {
        throw new Error("Failed to fetch issue");
      }
      const data = await response.json();
      setIssue(data.data);
    } catch (err) {
      setError("Error fetching issue");
      console.error("Error fetching issue:", err);
    } finally {
      setIsLoading(false);
    }
  };

  if (isLoading) return <div className="text-center mt-20">Loading...</div>;
  if (error)
    return <div className="text-center mt-20 text-red-500">Error: {error}</div>;
  if (!issue) return <div className="text-center mt-20">No issue found</div>;

  return (
    <div className="max-w-4xl mx-auto px-4 py-8 mt-20">
      {issue.creator && (
        <div className="mt-8">
          <h2 className="text-xl font-semibold mb-2">Created by:</h2>
          <p>{issue.creator.username}</p>
          <p>{issue.creator.email}</p>
        </div>
      )}
      <h3 className="text-3xl font-bold mb-4">{issue.prompt}</h3>
      <p className="text-gray-600 mb-4">Status: {issue.status}</p>
      <p className="text-gray-600 mb-4">
        Created at: {new Date(issue.createdAt).toLocaleString()}
      </p>
      <div className="mt-4">
        <h2 className="text-xl font-semibold mb-2">Tags:</h2>
        <div className="flex flex-wrap gap-2">
          {issue.tag.split(",").map((tag, index) => (
            <span
              key={index}
              className="bg-blue-100 text-blue-800 px-2 py-1 rounded-full text-sm"
            >
              #{tag.trim()}
            </span>
          ))}
        </div>
      </div>
    </div>
  );
}

// File: app/issues/[id]/page.js
"use client";

import { useEffect, useState } from "react";
import { useParams } from "next/navigation";
import { useAuth } from "../../context/AuthContext";
import Image from "next/image";

export default function IssuePage() {
  const [issue, setIssue] = useState(null);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState(null);
  const params = useParams();
  const { id } = params;
  const { user } = useAuth();

  useEffect(() => {
    if (id) {
      fetchIssue();
    }
  }, [id]);

  const fetchIssue = async () => {
    try {
      const response = await fetch(`/api/issues/${id}`, {
        headers: {
          Authorization: `Bearer ${user.token}`,
        },
      });
      if (!response.ok) {
        throw new Error("Failed to fetch issue");
      }
      const data = await response.json();
      setIssue(data.data);
    } catch (err) {
      setError("Error fetching issue");
      console.error("Error fetching issue:", err);
    } finally {
      setIsLoading(false);
    }
  };

  if (isLoading) return <div className="text-center mt-20">Loading...</div>;
  if (error)
    return <div className="text-center mt-20 text-red-500">Error: {error}</div>;
  if (!issue) return <div className="text-center mt-20">No issue found</div>;

  return (
    <div className="max-w-4xl mx-auto px-4 py-8 mt-20">
      <div className="mb-8 bg-gray-100 p-4 rounded-lg">
        <h2 className="text-xl font-semibold mb-2">Created by:</h2>
        <div className="flex items-center space-x-3">
          <div className="w-10 h-10 bg-gray-200 rounded-full flex items-center justify-center overflow-hidden">
            {issue.creatorImage ? (
              <Image
                src={issue.creatorImage}
                alt={issue.creatorName || "Creator"}
                width={40}
                height={40}
                className="object-cover"
              />
            ) : (
              (issue.creatorName || "A").charAt(0).toUpperCase()
            )}
          </div>
          <div>
            <p className="text-lg">{issue.creatorName || "Anonymous"}</p>
            <p className="text-gray-600">{issue.creatorEmail || "No Email"}</p>
          </div>
        </div>
      </div>
      <h1 className="text-3xl font-bold mb-4">{issue.prompt}</h1>
      <p className="text-gray-600 mb-4">Status: {issue.status}</p>
      <p className="text-gray-600 mb-4">
        Category: {issue.category || "Uncategorized"}
      </p>
      <p className="text-gray-600 mb-4">
        Created at: {new Date(issue.createdAt).toLocaleString()}
      </p>
      <div className="mt-4">
        <h2 className="text-xl font-semibold mb-2">Tags:</h2>
        <div className="flex flex-wrap gap-2">
          {issue.tag.split(",").map((tag, index) => (
            <span
              key={index}
              className="bg-blue-100 text-blue-800 px-2 py-1 rounded-full text-sm"
            >
              #{tag.trim()}
            </span>
          ))}
        </div>
      </div>
    </div>
  );
}

// File: app/issues/page.js
// File: app/issues/page.js
"use client";
import { useState } from "react";
import { useRouter } from "next/navigation";
import { useAuth } from "../context/AuthContext";

const categories = [
  "All",
  "Teaching",
  "Women Rights",
  "Ragging",
  "Cultural Events",
  "Campus",
  "Sports",
  "Fest",
  "Infrastructure",
  "Academics",
  "Student Services",
  "Extracurricular Activities",
];

async function createIssue(token, prompt, tag, category) {
  try {
    const response = await fetch("/api/issues/new_issues", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Authorization: `Bearer ${token}`,
      },
      body: JSON.stringify({ prompt, tag, category }),
    });

    if (!response.ok) {
      const errorMessage = await response.text();
      throw new Error(`Error creating issue: ${errorMessage}`);
    }

    const result = await response.json();
    console.log("Issue created successfully:", result);
    return result;
  } catch (error) {
    console.error("Error creating issue:", error);
    throw error;
  }
}

export default function IssuesPage() {
  const [prompt, setPrompt] = useState("");
  const [tag, setTag] = useState("");
  const [category, setCategory] = useState("");
  const { user } = useAuth();
  const router = useRouter();

  const handleSubmit = async (e) => {
    e.preventDefault();
    if (!user) {
      alert("You must be signed in to create an issue.");
      return;
    }
    try {
      await createIssue(user.token, prompt, tag, category);
      setPrompt("");
      setTag("");
      setCategory("");
      alert("Issue created successfully!");
      router.push("/");
    } catch (error) {
      alert("Failed to create issue. Please try again.");
    }
  };

  const handleCancel = () => {
    setPrompt("");
    setTag("");
    setCategory("");
    router.push("/");
  };

  return (
    <section className="w-full max-w-4xl pt-20 mx-auto px-4 py-12">
      <h1 className="text-4xl font-bold text-center text-gray-800 mb-4">
        Create New Issue
      </h1>
      <p className="text-xl text-center text-gray-600 mb-12 max-w-2xl mx-auto">
        Share your concerns with the college community. Your voice matters!
      </p>

      <form onSubmit={handleSubmit} className="mb-8">
        <textarea
          value={prompt}
          onChange={(e) => setPrompt(e.target.value)}
          placeholder="Describe your concern"
          required
          className="w-full h-40 p-4 mb-4 rounded-lg border border-gray-300 focus:outline-none focus:ring-2 focus:ring-blue-500"
        />
        <input
          type="text"
          value={tag}
          onChange={(e) => setTag(e.target.value)}
          placeholder="Add tags (comma-separated)"
          required
          className="w-full px-4 py-2 mb-4 rounded-lg border border-gray-300 focus:outline-none focus:ring-2 focus:ring-blue-500"
        />
        <select
          value={category}
          onChange={(e) => setCategory(e.target.value)}
          required
          className="w-full px-4 py-2 mb-4 rounded-lg border border-gray-300 focus:outline-none focus:ring-2 focus:ring-blue-500"
        >
          <option value="">Select a category</option>
          {categories.map((cat) => (
            <option key={cat} value={cat}>
              {cat}
            </option>
          ))}
        </select>
        <div className="flex justify-between">
          <button
            type="button"
            onClick={handleCancel}
            className="px-4 py-2 bg-red-600 text-white rounded-lg hover:bg-red-700 focus:outline-none focus:ring-2 focus:ring-red-500 focus:ring-offset-2"
          >
            Cancel
          </button>
          <button
            type="submit"
            className="px-3 py-1 bg-blue-600 text-white rounded-lg hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 text-sm"
          >
            Create Issue
          </button>
        </div>
      </form>
    </section>
  );
}

// File: app/layout.js
// File: app/layout.js
import { Inter } from "next/font/google";
import "./globals.css";
import Navigation from "../components/Navigation";
import { AuthContextProvider } from "./context/AuthContext";

const inter = Inter({ subsets: ["latin"] });

export const metadata = {
  title: "Student Voice",
  description: "Come Together and Share Your Voice!",
};

export default function RootLayout({ children }) {
  return (
    <html lang="en">
      <body>
        <AuthContextProvider>
          <Navigation />
          {children}
        </AuthContextProvider>
      </body>
    </html>
  );
}

// File: app/lib/actions/issue.action.js
import connectToDatabase from "@app/lib/mongoose";
import Issue from "@models/Issue";

export async function fetchIssues() {
  try {
    await connectToDatabase();
    const issues = await Issue.find({})
      .sort({ createdAt: -1 })
      .populate("author", "name image")
      .lean();
    return JSON.parse(JSON.stringify(issues));
  } catch (error) {
    console.error("Error fetching issues:", error);
    return null;
  }
}

// You can add other issue-related actions here in the future

// File: app/lib/actions/user.action.js
import connectToDatabase from "@app/lib/mongoose";
import User from "@/models/user.model";
import Problem from "@/models/problem.model";

export async function getUserProfile(userId) {
  try {
    await connectToDatabase();
    const user = await User.findById(userId).lean();
    if (!user) {
      throw new Error("User not found");
    }
    const problems = await Problem.find({ author: userId }).lean();
    return {
      ...user,
      problems,
    };
  } catch (error) {
    console.error("Error fetching user profile:", error);
    throw error;
  }
}

export async function deleteUserProblem(userId, problemId) {
  try {
    await connectToDatabase();
    const problem = await Problem.findOneAndDelete({
      _id: problemId,
      author: userId,
    });
    if (!problem) {
      throw new Error("Problem not found or user not authorized");
    }
    return problem;
  } catch (error) {
    console.error("Error deleting user problem:", error);
    throw error;
  }
}

// File: app/lib/dbConnect.js
import mongoose from "mongoose";

const MONGODB_URI = process.env.MONGODB_URI;

if (!MONGODB_URI) {
  throw new Error(
    "Please define the MONGODB_URI environment variable inside .env.local"
  );
}

let cached = global.mongoose;

if (!cached) {
  cached = global.mongoose = { conn: null, promise: null };
}

async function dbConnect() {
  if (cached.conn) {
    return cached.conn;
  }

  if (!cached.promise) {
    const opts = {
      bufferCommands: false,
    };

    cached.promise = mongoose.connect(MONGODB_URI, opts).then((mongoose) => {
      return mongoose;
    });
  }

  try {
    cached.conn = await cached.promise;
  } catch (e) {
    cached.promise = null;
    throw e;
  }

  return cached.conn;
}

export default dbConnect;

// File: app/lib/mongodb.js
import { MongoClient } from "mongodb";

if (!process.env.MONGODB_URI) {
  throw new Error('Invalid/Missing environment variable: "MONGODB_URI"');
}

const uri = process.env.MONGODB_URI;
const options = {};

let clientPromise;

if (!clientPromise) {
  const client = new MongoClient(uri, options);
  clientPromise = client.connect();
}

export default clientPromise;

// File: app/log-issues/index.js
"use client";
import Form from "@/components/Form";
import { useState } from "react";
import { useRouter } from "next/navigation";
import { UserAuth } from "@/app/context/AuthContext";

const CreateIssue = () => {
  const router = useRouter();
  const { user } = UserAuth();
  const [submitting, setSubmitting] = useState(false);
  const [post, setPost] = useState({ prompt: "", tag: "" });

  const createIssue = async (e) => {
    e.preventDefault();
    setSubmitting(true);

    if (!user) return alert("You must be signed in to create an issue.");

    try {
      const response = await fetch("/api/issues/new_issues", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          userId: user.uid,
          prompt: post.prompt,
          tag: post.tag,
        }),
      });

      if (response.ok) {
        router.push("/");
      } else {
        console.error("Failed to create issue:", await response.text());
      }
    } catch (error) {
      console.error("Failed to create issue:", error.message);
    } finally {
      setSubmitting(false);
    }
  };

  return (
    <Form
      type="Create"
      post={post}
      setPost={setPost}
      submitting={submitting}
      handleSubmit={createIssue}
    />
  );
};

export default CreateIssue;

// File: app/page.js
// File: app/page.js
"use client";
import React, { useEffect, useState } from "react";
import Feed from "../components/Feed";
import { useAuth } from "./context/AuthContext";
import { useSearchParams } from "next/navigation";

export default function Home() {
  const [issues, setIssues] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  const { user } = useAuth();
  const searchParams = useSearchParams();
  const category = searchParams.get("category");

  useEffect(() => {
    async function loadIssues() {
      if (!user) {
        setLoading(false);
        return;
      }
      try {
        setLoading(true);
        const response = await fetch("/api/issues", {
          headers: {
            Authorization: `Bearer ${user.token}`,
          },
        });
        if (response.ok) {
          const issuesData = await response.json();
          setIssues(issuesData);
        } else {
          throw new Error("Failed to fetch issues");
        }
      } catch (error) {
        console.error("Error loading issues:", error);
        setError("Failed to load issues. Please try again later.");
      } finally {
        setLoading(false);
      }
    }

    loadIssues();
  }, [user]);

  const filteredIssues =
    category && category !== "All"
      ? issues.filter((issue) => issue.category === category)
      : issues;

  if (loading) {
    return (
      <main className="flex min-h-screen flex-col items-center justify-center p-4 pt-10 sm:p-24">
        <p>Loading...</p>
      </main>
    );
  }

  if (error) {
    return (
      <main className="flex min-h-screen flex-col items-center justify-center p-4 pt-10 sm:p-24">
        <div
          className="bg-red-100 border-l-4 border-red-500 text-red-700 p-4 mb-8"
          role="alert"
        >
          <p className="font-bold">Error</p>
          <p>{error}</p>
        </div>
      </main>
    );
  }

  return (
    <main className="flex min-h-screen flex-col items-center justify-between p-4 pt-10 sm:p-24 ">
      <section className="w-full max-w-4xl mx-auto px-4 py-8 pt-10 sm:py-12 text-center">
        <h1 className="text-3xl sm:text-4xl font-bold text-gray-800 mb-4">
          <span className="text-black mt-3 pt-8">Student Voice</span>
          <br className="hidden sm:block" />
          <span className="text-black">College Community Concerns</span>
        </h1>
        <p className="text-lg sm:text-xl text-gray-600 mb-8 sm:mb-12 max-w-2xl mx-auto">
          Explore issues raised by students in our college community. Voice your
          support and make a difference.
        </p>

        {user ? (
          <Feed initialIssues={filteredIssues} />
        ) : (
          <div
            className="bg-yellow-100 border-l-4 border-yellow-500 text-yellow-700 p-4 mb-8"
            role="alert"
          >
            <p className="font-bold">Please log in</p>
            <p>You need to be logged in to view and interact with issues.</p>
          </div>
        )}
      </section>
    </main>
  );
}

// File: app/profile/[id]/index.js
/**app/profile/[id]/index.js */
"use client";

import { useEffect, useState } from "react";
import { useSearchParams } from "next/navigation";
import Profile from "@components/Profile";

const UserProfile = ({ params }) => {
  const searchParams = useSearchParams();
  const userName = searchParams.get("name");
  const [userPosts, setUserPosts] = useState([]);

  useEffect(() => {
    const fetchPosts = async () => {
      try {
        const response = await fetch(`/api/students/${params.id}/posts`);
        if (response.ok) {
          const data = await response.json();
          setUserPosts(data);
        } else {
          console.error("Failed to fetch user posts:", await response.text());
        }
      } catch (error) {
        console.error("Failed to fetch user posts:", error.message);
      }
    };

    if (params.id) fetchPosts();
  }, [params.id]);

  return (
    <Profile
      name={userName}
      desc={`Welcome ${userName}, do share your experiences`}
      data={userPosts}
    />
  );
};

export default UserProfile;

// File: app/profile/page.js
// File: app/profile/page.js
"use client";
import { useEffect, useState } from "react";
import { useAuth } from "../context/AuthContext";
import ProblemCard from "../../components/ProblemCard";

const ProfilePage = () => {
  const { user } = useAuth();
  const [myIssues, setMyIssues] = useState([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState(null);

  useEffect(() => {
    const fetchIssues = async () => {
      if (!user) {
        setIsLoading(false);
        return;
      }
      try {
        const response = await fetch(`/api/issues`, {
          headers: {
            Authorization: `Bearer ${user.token}`,
          },
        });
        if (response.ok) {
          const data = await response.json();
          // Filter issues created by the current user
          const userIssues = data.filter((issue) => issue.creator === user.uid);
          setMyIssues(userIssues || []);
        } else {
          throw new Error(await response.text());
        }
      } catch (error) {
        console.error("Failed to fetch my issues:", error.message);
        setError("Failed to load issues. Please try again later.");
      } finally {
        setIsLoading(false);
      }
    };

    fetchIssues();
  }, [user]);

  const deleteIssue = async (issueId) => {
    if (!user) return;

    try {
      const response = await fetch(`/api/issues/${issueId}`, {
        method: "DELETE",
        headers: {
          Authorization: `Bearer ${user.token}`,
        },
      });

      if (response.ok) {
        setMyIssues((prevIssues) =>
          prevIssues.filter((issue) => issue._id !== issueId)
        );
      } else {
        console.error("Failed to delete issue:", await response.text());
        alert("Failed to delete the issue. Please try again.");
      }
    } catch (error) {
      console.error("Failed to delete issue:", error.message);
      alert("Failed to delete the issue. Please try again.");
    }
  };

  if (!user) {
    return (
      <div className="text-center mt-20">
        Please sign in to view your profile.
      </div>
    );
  }

  if (isLoading) {
    return <div className="text-center mt-20">Loading...</div>;
  }

  if (error) {
    return <div className="text-center mt-20 text-red-500">{error}</div>;
  }

  return (
    <div className="w-full max-w-4xl mx-auto px-4 py-8 mt-20">
      <h1 className="text-2xl font-bold mb-4">My Profile</h1>
      <h2 className="text-xl font-semibold mb-2">My Issues</h2>
      {myIssues.length === 0 ? (
        <p>No issues found.</p>
      ) : (
        <div className="grid gap-4 md:grid-cols-2 lg:grid-cols-3">
          {myIssues.map((issue) => (
            <div key={issue._id} className="relative">
              <ProblemCard problem={issue} handleTagClick={() => {}} />
              <button
                className="mt-2 px-4 py-2 bg-red-500 text-white rounded absolute bottom-2 right-2"
                onClick={() => deleteIssue(issue._id)}
              >
                Delete
              </button>
            </div>
          ))}
        </div>
      )}
    </div>
  );
};

export default ProfilePage;

// File: app/update_log/page.js
"use client";

import { useEffect, useState } from "react";
import { useRouter, useSearchParams } from "next/navigation";
import Form from "../../components/Form";
const UpdatePrompt = () => {
  const router = useRouter();
  const searchParams = useSearchParams();
  const promptId = searchParams.get("id");

  const [post, setPost] = useState({ prompt: "", tag: "" });
  const [submitting, setIsSubmitting] = useState(false);

  useEffect(() => {
    const getPromptDetails = async () => {
      try {
        const response = await fetch(`/api/issues/${promptId}`);
        if (response.ok) {
          const data = await response.json();
          setPost({ prompt: data.prompt, tag: data.tag });
        } else {
          console.error(
            "Failed to fetch prompt details:",
            await response.text()
          );
        }
      } catch (error) {
        console.error("Failed to fetch prompt details:", error.message);
      }
    };

    if (promptId) getPromptDetails();
  }, [promptId]);

  const updatePrompt = async (e) => {
    e.preventDefault();
    setIsSubmitting(true);

    if (!promptId) return alert("Missing LogId!");

    try {
      const response = await fetch(`/api/issues/${promptId}`, {
        method: "PATCH",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          prompt: post.prompt,
          tag: post.tag,
        }),
      });

      if (response.ok) {
        router.push("/");
      } else {
        console.error("Failed to update prompt:", await response.text());
      }
    } catch (error) {
      console.error("Failed to update prompt:", error.message);
    } finally {
      setIsSubmitting(false);
    }
  };

  return (
    <Form
      type="Edit"
      post={post}
      setPost={setPost}
      submitting={submitting}
      handleSubmit={updatePrompt}
    />
  );
};

export default UpdatePrompt;

// File: utils/db.js
import mongoose from "mongoose";

const MONGODB_URI = process.env.MONGODB_URI;

if (!MONGODB_URI) {
  throw new Error(
    "Please define the MONGODB_URI environment variable inside .env.local"
  );
}

let cached = global.mongoose;

if (!cached) {
  cached = global.mongoose = { conn: null, promise: null };
}

export async function connectToDB() {
  if (cached.conn) {
    return cached.conn;
  }

  if (!cached.promise) {
    const opts = {
      bufferCommands: false,
    };

    cached.promise = mongoose.connect(MONGODB_URI, opts).then((mongoose) => {
      return mongoose;
    });
  }

  try {
    cached.conn = await cached.promise;
  } catch (e) {
    cached.promise = null;
    throw e;
  }

  return cached.conn;
}

// File: utils/firebase-admin.js
// utils/firebase-admin.js

import { initializeApp, getApps, cert } from "firebase-admin/app";
import { getAuth } from "firebase-admin/auth";

const firebaseConfig = {
  type: process.env.FIREBASE_TYPE,
  project_id: process.env.FIREBASE_PROJECT_ID,
  private_key_id: process.env.FIREBASE_PRIVATE_KEY_ID,
  private_key: process.env.FIREBASE_PRIVATE_KEY.replace(/\\n/g, "\n"),
  client_email: process.env.FIREBASE_CLIENT_EMAIL,
  client_id: process.env.FIREBASE_CLIENT_ID,
  auth_uri: process.env.FIREBASE_AUTH_URI,
  token_uri: process.env.FIREBASE_TOKEN_URI,
  auth_provider_x509_cert_url: process.env.FIREBASE_AUTH_PROVIDER_X509_CERT_URL,
  client_x509_cert_url: process.env.FIREBASE_CLIENT_X509_CERT_URL,
  universe_domain: process.env.FIREBASE_UNIVERSE_DOMAIN,
};

export function initializeFirebaseAdmin() {
  if (!getApps().length) {
    try {
      initializeApp({
        credential: cert(firebaseConfig),
      });
      console.log("Firebase Admin initialized successfully.");
    } catch (error) {
      console.error("Failed to initialize Firebase Admin SDK:", error);
    }
  }
}

export { getAuth };

